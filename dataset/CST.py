__author__ = 'ryanbarr'

# Description : Create a set of airfoil coordinates using CST parametrization method
# Input  : wl = CST weight of lower surface
#          wu = CST weight of upper surface
#          dz = trailing edge thickness
# Output : coord = set of x-y coordinates of airfoil generated by CST
#
# Adapted from:
#           Airfoil generation using CST parameterization method
#           by Pramudita Satria Palar
#           17 Jun 2013
#           http://www.mathworks.com/matlabcentral/fileexchange/42239-airfoil-generation-using-cst-parameterization-method

import numpy as np
from math import pi, cos, sin, factorial
import matplotlib.pylab as plt
import os


class CST_shape():
    def __init__(self, filename, wl=[-1, -1, -1], wu=[1, 1, 1], dz=0, N=200):
        self.wl = wl
        self.wu = wu
        self.dz = dz
        self.N = N
        self.filename = filename
        self.airfoil_coor()

    def airfoil_coor(self):
        wl = self.wl
        wu = self.wu
        dz = self.dz
        N = self.N

        # Create x coordinate
        x = np.ones((N, 1))
        y = np.zeros((N, 1))
        zeta = np.zeros((N, 1))

        for i in range(0, N):
            zeta[i] = 2 * pi / N * i
            x[i] = 0.5*(cos(zeta[i])+1)

        # N1 and N2 parameters (N1 = 0.5 and N2 = 1 for airfoil shape)
        N1 = 0.5
        N2 = 1

        # Used to separate upper and lower surfaces
        center_loc = np.where(x == 0)
        center_loc = center_loc[0][0]

        xl = np.zeros(center_loc)
        xu = np.zeros(N-center_loc)

        for i in range(len(xl)):
            xl[i] = x[i]            # Lower surface x-coordinates
        for i in range(len(xu)):
            xu[i] = x[i + center_loc]   # Upper surface x-coordinates

        assert len(xl) == len(xu)

        # Call ClassShape function to determine lower surface y-coordinates
        yl = self.__ClassShape(wl, xl, N1, N2, -dz)
        # Call ClassShape function to determine upper surface y-coordinates
        yu = self.__ClassShape(wu, xu, N1, N2, dz)

        y = np.concatenate([yl, yu])  # Combine upper and lower y coordinates

        self.coord = [x, y]  # Combine x and y into single output

        # self.plotting()
        self.__writeToFile(xl, yl, xu, yu)

    def inv_airfoil_coor(self, x):
        wl = self.wl
        wu = self.wu
        dz = self.dz
        N = self.N

        # N1 and N2 parameters (N1 = 0.5 and N2 = 1 for airfoil shape)
        N1 = 0.5
        N2 = 1

        # Used to separate upper and lower surfaces
        center_loc = np.where(x == 0)
        center_loc = center_loc[0][0]

        xl = np.zeros(center_loc)
        xu = np.zeros(N-center_loc)

        for i in range(len(xl)):
            xl[i] = x[i]            # Lower surface x-coordinates
        for i in range(len(xu)):
            xu[i] = x[i + center_loc]   # Upper surface x-coordinates

        # Call ClassShape function to determine lower surface y-coordinates
        yl = self.__ClassShape(wl, xl, N1, N2, -dz)
        # Call ClassShape function to determine upper surface y-coordinates
        yu = self.__ClassShape(wu, xu, N1, N2, dz)

        y = np.concatenate([yl, yu])  # Combine upper and lower y coordinates

        self.coord = [x, y]  # Combine x and y into single output

        # self.plotting()
        self.__writeToFile(x, y)

    # Function to calculate class and shape function
    def __ClassShape(self, w, x, N1, N2, dz):

        # Class function; taking input of N1 and N2
        C = np.zeros(len(x))
        for i in range(len(x)):
            C[i] = x[i]**N1*((1-x[i])**N2)

        # Shape function; using Bernstein Polynomials
        n = len(w) - 1  # Order of Bernstein polynomials

        K = np.zeros(n+1)
        for i in range(0, n+1):
            K[i] = factorial(n)/(factorial(i)*(factorial((n)-(i))))

        S = np.zeros(len(x))
        for i in range(len(x)):
            S[i] = 0
            for j in range(0, n+1):
                S[i] += w[j]*K[j]*x[i]**(j) * ((1-x[i])**(n-(j)))

        # Calculate y output
        y = np.zeros(len(x))
        for i in range(len(y)):
            y[i] = C[i] * S[i] + x[i] * dz

        return y

    def __writeToFile(self, xl, yl, xu, yu):

        basepath = os.path.dirname(os.path.realpath(__file__))
        airfoil_shape_file = basepath + os.path.sep + self.filename + '.dat'

        coord_file = open(airfoil_shape_file, 'w')
        print(len(xl), file=coord_file)
        for i in range(len(xl)):
            print('{:<10f}\t{:<10f}'.format(
                float(xl[i]), float(yl[i])), float(0), file=coord_file)
        print(len(xu), file=coord_file)
        for i in range(len(xu)):
            print('{:<10f}\t{:<10f}'.format(
                float(xu[i]), float(yu[i])), float(0), file=coord_file)
        print(2, file=coord_file)
        print('{:<10f}\t{:<10f}'.format(
            float(xu[-1]), float(yu[-1])), float(0), file=coord_file)
        print('{:<10f}\t{:<10f}'.format(
            float(xl[0]), float(yl[0])), float(0), file=coord_file)
        coord_file.close()

    def plotting(self):
        x_coor = self.coord[0]
        y_coor = self.coord[1]
        fig7 = plt.figure()
        ax7 = plt.subplot(111)
        ax7.plot(x_coor, y_coor)
        plt.xlabel('x/c')
        plt.ylabel('y/c')
        plt.ylim(ymin=-0.75, ymax=0.75)
        ax7.spines['right'].set_visible(False)
        ax7.spines['top'].set_visible(False)
        ax7.yaxis.set_ticks_position('left')
        ax7.xaxis.set_ticks_position('bottom')
        plt.show()


if __name__ == '__main__':
    wu = [1, 1, 1]           # Upper surface
    wl = [-0.2, -0.2, -0.2, -0.1]    # Lower surface
    dz = 0.001
    N = 300
    filename = 'CST'
    airfoil_CST = CST_shape(filename, wl, wu, dz, N)
    del airfoil_CST
